import { API, DynamicPlatformPlugin, Logger, PlatformAccessory, PlatformConfig, Service, Characteristic } from 'homebridge';
import { AirtouchAPI } from './api';
import { MAGIC } from './magic';

import type { uuid } from 'homebridge';
let Accessory: typeof PlatformAccessory;
let UUIDGen: typeof uuid;

export class AirtouchPlatform implements DynamicPlatformPlugin {


  units;
  zones;
  thermostats;
  context;
  airtouch!: AirtouchAPI;
  log;
  config;
  //
  // Airtouch platform
  // Homebridge platform which creates accessories for AC units and AC zones
  // Handles communication with the Airtouch Touchpad Controller using the Airtouch API
  //
  constructor (
    public readonly input_log: Logger,
    public readonly input_config: PlatformConfig,
    public readonly input_api: API,
  ) {
    this.log = input_log;
    this.config = input_config;
    this.api = input_api;

    this.log.debug('Starting to set up Airtouch5 platform.');

    // initialize accessory lists
    this.units = {};
    this.zones = {};
    this.thermostats = {};

    // set up callbacks from API
    this.airtouch = new AirtouchAPI(input_log);
    this.airtouch.on('ac_status', (ac_status) => {
      this.onACStatusNotification(ac_status);
    });
    this.airtouch.on('groups_status', (group_status) => {
      this.onGroupsStatusNotification(group_status);
    });


    // will try to reconnect on api error - worried this might end up causing a loop..
    // this.api.on("attempt_reconnect", () => {
    // 	this.api.connect(config.ip_address);
    // });

    // // connect to the Airtouch Touchpad Controller
    // this.api.connect(config.ip_address);

    this.airtouch.on('didFinishLaunching', () => {
      this.log.debug('Executed didFinishLaunching callback');
      // run the method to discover / register your devices as accessories
      this.discoverDevices();
    });
  }

  async discoverDevices() {
    this.log.debug('Beginning to discover devices');
    this.config.units.forEach(this.beginConfigurationOfUnit);
  }

  beginConfigurationOfUnit(unit) {
    this.log.debug('Configuring device: '+JSON.stringify(unit));
    this.log.info(unit);
  }

  // configure cached accessories
  configureAccessory(accessory) {
    this.log.debug('Trying to configure [' + accessory.displayName + '] from cache...');

    if (accessory.displayName in this.units || accessory.displayName in this.zones) {
      this.log('[' + accessory.displayName + '] is already configured');
      return;
    }

    accessory.reacheable = false;
    accessory.log = this.log;
    accessory.api = this.airtouch;

    if (accessory.displayName.startsWith('AC')) {
      this.setupACAccessory(accessory);
      this.units[accessory.displayName] = accessory;
    } else if (accessory.displayName.startsWith('Zone') && accessory.displayName.endsWith('Thermostat')) {
      this.setupThermoAccessory(accessory);
      this.thermostats[accessory.displayName] = accessory;
    } else if (accessory.displayName.startsWith('Zone')) {
      this.setupZoneAccessory(accessory);
      this.zones[accessory.displayName] = accessory;
    }

    this.log('[' + accessory.displayName + '] was restored from cache and should be reachable');
  }


  // callback for AC messages received from Airtouch Touchpad Controller
  onACStatusNotification(ac_status) {
    ac_status.forEach(unit_status => {
      const unit_name = 'AC ' + unit_status.ac_unit_number;
      this.log.debug('Received status update for [' + unit_name + ']: ' + JSON.stringify(unit_status));
      // check if accessory exists
      if (!(unit_name in this.units)) {
        this.log.debug('[' + unit_name + '] was not found, creating as new AC accessory...');
        const uuid = UUIDGen.generate(unit_name);
        const unit = new Accessory(unit_name, uuid);
        unit.log = this.log;
        unit.api = this.airtouch;
        unit.context.manufacturer = this.config.units[unit_status.ac_unit_number].manufacturer || 'N/A';
        unit.context.model = this.config.units[unit_status.ac_unit_number].model || 'N/A';
        unit.context.serial = unit_status.ac_unit_number;
        if (unit_status.ac_power_state === 0) { // OFF
          unit.context.currentHeatingCoolingState = 0;
        } else if (unit_status.ac_mode === 1) { // HEAT
          unit.context.currentHeatingCoolingState = 1;
        } else if (unit_status.ac_mode === 4) {// COOL
          unit.context.currentHeatingCoolingState = 2;
        } else { // AUTO, for: 2=DRY, 3=FAN, 8=AUTO-HEAT, 9=AUTO-COOL
          unit.context.currentHeatingCoolingState = 3;
        }
        unit.context.targetHeatingCoolingState = unit.context.currentHeatingCoolingState;
        unit.context.currentTemperature = unit_status.ac_temp;
        unit.context.targetTemperature = unit_status.ac_target;
        // convert AC fan speed number in AC fan speed string (e.g. 4 => High)
        // let fan_speed = Object.keys(MAGIC.AC_FAN_SPEEDS).find(key => MAGIC.AC_FAN_SPEEDS[key] === unit_status.ac_fan_speed);
        // convert AC fan speed string into homebridge fan rotation % (e.g. High => 99%) using the config array
        // unit.context.rotationSpeed = unit.context.fan_speeds.indexOf(fan_speed) * accessory.context.rotation_step;



        this.setupACAccessory(unit);
        this.units[unit_name] = unit;
        this.platform.registerPlatformAccessories('homebridge-airtouch5-platform', 'Airtouch5', [unit]);
      }
      // update accessory
      this.updateACAccessory(this.units[unit_name], unit_status);
    });
  }

  // callback for Group messages received from Airtouch Touchpad Controller
  onGroupsStatusNotification(groups_status) {
    groups_status.forEach(zone_status => {
      const zone_name = 'Zone ' + zone_status.group_number;
      this.log.debug('Received status update for [' + zone_name + ']: ' + JSON.stringify(zone_status));
      // check if accessory exists
      if (!(zone_name in this.zones)) {
        this.log.debug('[' + zone_name + '] was not found, creating as new Zone accessory...');
        const uuid = UUIDGen.generate(zone_name);
        const zone = new PlatformAccessory(zone_name, uuid);
        zone.log = this.log;
        zone.api = this.airtouch;
        zone.context.manufacturer = 'Polyaire';
        zone.context.model = 'Airtouch5 Damper';
        zone.context.serial = 'Serial ' + zone_status.group_number;
        this.setupThermoAccessory(zone);
        this.zones[zone_name] = zone;
        this.platform.registerPlatformAccessories('homebridge-airtouch5-platform', 'Airtouch5', [zone]);
      }
      // update accessory
      this.updateThermoAccessory(this.zones[zone_name], zone_status);
    });
  }

  // setup AC accessory callbacks
  setupACAccessory(accessory) {
    accessory.on('identify', (paired, cb) => {
      this.log(accessory.displayName, ' identified');
      cb();
    });

    accessory.getService(Service.AccessoryInformation)
      .setCharacteristic(Characteristic.Manufacturer, accessory.context.manufacturer)
      .setCharacteristic(Characteristic.Model, accessory.context.model)
      .setCharacteristic(Characteristic.SerialNumber, 'Serial Number ' + accessory.context.serial.toString());

    let thermostat = accessory.getService(Service.Thermostat);
    if (thermostat === undefined) {
      thermostat = accessory.addService(Service.Thermostat, accessory.displayName);
    }

    thermostat
      .getCharacteristic(Characteristic.CurrentHeatingCoolingState)
      .on('get', function(cb){
        return cb(null, this.context.currentHeatingCoolingState);
      }.bind(accessory));

    thermostat
      .getCharacteristic(Characteristic.TargetHeatingCoolingState)
      .on('get', function(cb){
        return cb(null, this.context.targetHeatingCoolingState);
      }.bind(accessory))
      .on('set', this.acSetTargetHeatingCoolingState.bind(accessory));

    thermostat
      .getCharacteristic(Characteristic.CurrentTemperature)
      .on('get', function(cb){
        return cb(null, this.context.currentTemperature);
      }.bind(accessory));

    thermostat
      .getCharacteristic(Characteristic.TargetTemperature)
      .setProps({
        minStep: 1.0,
        minValue: 14.0,
        maxValue: 29.0})
      .on('get', function(cb){
        return cb(null, this.context.targetTemperature);
      }.bind(accessory))
      .on('set', this.acSetTargetTemperature.bind(accessory));

    accessory.context.temperatureDisplayUnits = 0; // defaults to Celsius
    thermostat
      .getCharacteristic(Characteristic.TemperatureDisplayUnits)
      .on('get', function(cb){
        return cb(null, this.context.temperatureDisplayUnits);
      }.bind(accessory))
      .on('set', function(val, cb){
        this.context.temperatureDisplayUnits = val; cb();
      }.bind(accessory));

    thermostat
      .getCharacteristic(Characteristic.Name)
      .on('get', function(cb){
        return cb(null, this.displayName);
      }.bind(accessory));

    accessory.context.fan_speeds = this.config.units[accessory.context.serial].fan;
    accessory.context.rotation_step = Math.floor(100/(Object.keys(accessory.context.fan_speeds).length-1));
    let fan = thermostat.getCharacteristic(Characteristic.RotationSpeed);
    if (fan === undefined) {
      fan = thermostat.addCharacteristic(Characteristic.RotationSpeed);
    }
    fan.setProps({
      minStep: accessory.context.rotation_step,
      minValue: 0,
      maxValue: accessory.context.rotation_step*(Object.keys(accessory.context.fan_speeds).length-1)})
      .on('get', function(cb){
        return cb(null, this.context.rotationSpeed);
      }.bind(accessory))
      .on('set', this.acSetRotationSpeed.bind(accessory));

    thermostat.isPrimaryService = true;


    this.log.debug('Finished creating accessory [' + accessory.displayName + ']');
  }

  // update AC accessory data
  updateACAccessory(accessory, status) {
    const thermostat = accessory.getService(Service.Thermostat);

    if (status.ac_power_state === 0) { // OFF
      accessory.context.currentHeatingCoolingState = 0;
    } else if (status.ac_mode === 1) { // HEAT
      accessory.context.currentHeatingCoolingState = 1;
    } else if (status.ac_mode === 4) { // COOL
      accessory.context.currentHeatingCoolingState = 2;
    } else { // AUTO, for: 2=DRY, 3=FAN, 8=AUTO-HEAT, 9=AUTO-COOL
      accessory.context.currentHeatingCoolingState = 3;
    }
    thermostat.setCharacteristic(Characteristic.CurrentHeatingCoolingState, accessory.context.currentHeatingCoolingState);

    accessory.context.targetHeatingCoolingState = accessory.context.currentHeatingCoolingState;
    thermostat.setCharacteristic(Characteristic.TargetHeatingCoolingState, accessory.context.targetHeatingCoolingState);

    accessory.context.currentTemperature = status.ac_temp;
    thermostat.setCharacteristic(Characteristic.CurrentTemperature, accessory.context.currentTemperature);

    accessory.context.targetTemperature = status.ac_target;
    thermostat.setCharacteristic(Characteristic.TargetTemperature, accessory.context.targetTemperature);

    // convert AC fan speed number in AC fan speed string (e.g. 4 => High)
    const fan_speed = Object.keys(MAGIC.AC_FAN_SPEEDS).find(key => MAGIC.AC_FAN_SPEEDS[key] === status.ac_fan_speed);
    // convert AC fan speed string into homebridge fan rotation % (e.g. High => 99%) using the config array
    accessory.context.rotationSpeed = accessory.context.fan_speeds.indexOf(fan_speed) * accessory.context.rotation_step;
    thermostat.setCharacteristic(Characteristic.RotationSpeed, accessory.context.rotationSpeed);

    // save history as Eve Thermo
    // let now = new Date().getTime() / 1000;
    // if (now - accessory.historyUpdate > 285) { // 285s = 4.75 min update intervals
    // 	accessory.historyService.addEntry({
    // 		time: now,
    // 		currentTemp: accessory.context.currentTemperature,
    // 		setTemp: accessory.context.targetTemperature,
    // 		valvePosition: accessory.context.rotationSpeed
    // 	});
    // 	accessory.historyUpdate = now;
    // }

    // accessory.context.statusFault = status.ac_error_code;
    // thermostat.setCharacteristic(Characteristic.StatusFault, accessory.context.statusFault);

    // accessory.context.spillStatus = status.ac_spill;
    // thermostat.setCharacteristic(CustomCharacteristic.SpillStatus, accessory.context.spillStatus);

    // accessory.context.timerStatus = status.ac_timer;
    // thermostat.setCharacteristic(CustomCharacteristic.TimerStatus, accessory.context.timerStatus);

    accessory.updateReachability(true);
    this.log.debug('Finished updating accessory [' + accessory.displayName + ']');
  }

  // setup Zone accessory callbacks
  setupZoneAccessory(accessory) {
    accessory.on('identify', (paired, cb) => {
      this.log(accessory.displayName, ' identified');
      cb();
    });

    accessory.getService(Service.AccessoryInformation)
      .setCharacteristic(Characteristic.Manufacturer, accessory.context.manufacturer)
      .setCharacteristic(Characteristic.Model, accessory.context.model)
      .setCharacteristic(Characteristic.SerialNumber, accessory.context.serial.toString());

    let zone = accessory.getService(Service.Switch);
    if (zone === undefined) {
      zone = accessory.addService(Service.Switch, accessory.displayName);
    }

    zone
      .getCharacteristic(Characteristic.On)
      .on('get', function(cb){
        return cb(null, this.context.active);
      }.bind(accessory))
      .on('set', this.zoneSetActive.bind(accessory));

    zone
      .getCharacteristic(Characteristic.Name)
      .on('get', function(cb){
        return cb(null, this.displayName);
      }.bind(accessory));

    zone.isPrimaryService = true;

    // let damper = accessory.getService(Service.Window);
    // if (damper === undefined)
    // 	damper = accessory.addService(Service.Window, accessory.displayName + " Damper");

    // damper
    // 	.getCharacteristic(Characteristic.CurrentPosition)
    // 	.on("get", function(cb){ return cb(null, this.context.damperPosition); }.bind(accessory));

    // damper
    // 	.getCharacteristic(Characteristic.TargetPosition)
    // 	.setProps({
    // 		minStep: 5,
    // 		minValue: 0,
    // 		maxValue: 100})
    // 	.on("get", function(cb){ return cb(null, this.context.targetPosition); }.bind(accessory))
    // 	.on("set", this.zoneSetDamperPosition.bind(accessory));

    // damper
    // 	.getCharacteristic(Characteristic.PositionState)
    // 	.on("get", function(cb){ return cb(null, 2); }.bind(accessory)); // show status as STOPPED, don't track intermediary movements

    // damper
    // 	.getCharacteristic(Characteristic.Name)
    // 	.on("get", function(cb){ return cb(null, this.displayName + " Damper"); }.bind(accessory));

    // zone.addLinkedService(damper);

    // let sensor = accessory.getService(Service.TemperatureSensor);
    // if (sensor === undefined)
    // 	sensor = accessory.addService(Service.TemperatureSensor, accessory.displayName + " Sensor");

    // sensor
    // 	.getCharacteristic(Characteristic.CurrentTemperature)
    // 	.on("get", function(cb){ return cb(null, this.context.currentTemperature); }.bind(accessory));

    // sensor
    // 	.getCharacteristic(Characteristic.StatusLowBattery)
    // 	.on("get", function(cb){ return cb(null, this.context.sensorLowBattery); }.bind(accessory));

    // sensor.setHiddenService(true);
    // zone.addLinkedService(sensor);


    this.log('Finished creating accessory [' + accessory.displayName + ']');
  }

  // update Zone accessory data
  updateZoneAccessory(accessory, status) {
    const zone = accessory.getService(Service.Switch);
    // let damper = accessory.getService(Service.Window);
    const sensor = accessory.getService(Service.TemperatureSensor);

    accessory.context.active = status.group_power_state % 2;
    zone.setCharacteristic(Characteristic.Active, accessory.context.active);

    accessory.context.controlType = status.group_control_type;
    // when using temperature control, set the damper as obstructed
    // damper.setCharacteristic(Characteristic.ObstructionDetected, accessory.context.controlType);

    // accessory.context.damperPosition = status.group_damper_position;
    // damper.setCharacteristic(Characteristic.CurrentPosition, accessory.context.damperPosition);
    // damper.setCharacteristic(Characteristic.TargetPosition, accessory.context.damperPosition);

    if (status.group_has_sensor) {
      if (sensor.isHiddenService) {
        sensor.setHiddenService(false);
      }

      accessory.context.currentTemperature = status.group_temp;
      sensor.setCharacteristic(Characteristic.CurrentTemperature, accessory.context.currentTemperature);

      accessory.context.sensorLowBattery = status.group_battery_low;
      sensor.setCharacteristic(Characteristic.StatusLowBattery, accessory.context.sensorLowBattery);

      // save history as Eve Light Switch
      // accessory.historyService.addEntry({
      // 	time: new Date().getTime() / 1000,
      // 	temp: accessory.context.currentTemperature,
      // 	status: accessory.context.active
      // });

      // update thermostat accessory
      thermo_name = accessory.displayName + ' Thermostat';
      this.log('Updating [' + thermo_name + ']');
      // check if accessory exists
      if (!(thermo_name in this.thermostats)) {
        this.log('[' + thermo_name + '] was not found, creating as new Thermostat accessory...');
        const uuid = UUIDGen.generate(thermo_name);
        const thermo = new Accessory(thermo_name, uuid);
        thermo.log = this.log;
        thermo.api = this.airtouch;
        thermo.context.manufacturer = 'Polyaire';
        thermo.context.model = 'Temperature Control Thermostat';
        thermo.context.serial = status.group_number;
        this.setupThermoAccessory(thermo);
        this.thermostats[thermo_name] = thermo;
        this.platform.registerPlatformAccessories('homebridge-airtouch5-platform', 'Airtouch5', [thermo]);
      }
      // update accessory
      this.updateThermoAccessory(this.thermostats[thermo_name], status);

      // show temperature in the AC accessory
      const ac = Object.entries(this.units)[0][1]; // get "AC 0"
      // this.log(ac);
      const ac_sensor = ac.getService(accessory.displayName); // get sensor "Zone <N>" from ac
      // if (this.config["ac_include_temps"] == true) {
      // 	if (ac_sensor === undefined)
      // 		ac.addService(Service.TemperatureSensor, accessory.displayName, accessory.displayName);
      // 	ac_sensor.setCharacteristic(Characteristic.CurrentTemperature, accessory.context.currentTemperature);
      // } else {
      // 	ac.removeService(ac_sensor);
      // }
    }

    accessory.updateReachability(true);
    this.log.debug('Finished updating accessory [' + accessory.displayName + ']');
  }

  // setup Thermo accessory callbacks
  setupThermoAccessory(accessory) {
    accessory.on('identify', (paired, cb) => {
      this.log(accessory.displayName, ' identified');
      cb();
    });

    accessory.getService(Service.AccessoryInformation)
      .setCharacteristic(Characteristic.Manufacturer, accessory.context.manufacturer)
      .setCharacteristic(Characteristic.Model, accessory.context.model)
      .setCharacteristic(Characteristic.SerialNumber, accessory.context.serial.toString());

    let thermo = accessory.getService(Service.Thermostat);
    if (thermo === undefined) {
      thermo = accessory.addService(Service.Thermostat, accessory.displayName);
    }

    thermo
      .getCharacteristic(Characteristic.CurrentHeatingCoolingState)
      .on('get', function(cb){
        return cb(null, this.context.currentHeatingCoolingState);
      }.bind(accessory));

    thermo
      .getCharacteristic(Characteristic.TargetHeatingCoolingState)
      .setProps({
        minStep: 3,
        minValue: 0,
        maxValue: 3,
        validValues: [0, 3]})
      .on('get', function(cb){
        return cb(null, this.context.active ? 3 : 0);
      }.bind(accessory))
      .on('set', this.thermoSetActive.bind(accessory));

    thermo
      .getCharacteristic(Characteristic.CurrentTemperature)
      .on('get', function(cb){
        return cb(null, this.context.currentTemperature);
      }.bind(accessory));

    thermo
      .getCharacteristic(Characteristic.TargetTemperature)
      .setProps({
        minStep: 1.0,
        minValue: 14.0,
        maxValue: 29.0})
      .on('get', function(cb){
        return cb(null, this.context.targetTemperature);
      }.bind(accessory))
      .on('set', this.thermoSetTargetTemperature.bind(accessory));

    accessory.context.temperatureDisplayUnits = 0; // defaults to Celsius
    thermo
      .getCharacteristic(Characteristic.TemperatureDisplayUnits)
      .on('get', function(cb){
        return cb(null, this.context.temperatureDisplayUnits);
      }.bind(accessory))
      .on('set', function(val, cb){
        this.context.temperatureDisplayUnits = val; cb();
      }.bind(accessory));

    thermo
      .getCharacteristic(Characteristic.Name)
      .on('get', function(cb){
        return cb(null, this.displayName);
      }.bind(accessory));

    thermo.isPrimaryService = true;


    this.log('Finished creating accessory [' + accessory.displayName + ']');
  }

  // update Thermo accessory data
  updateThermoAccessory(accessory, status) {
    const thermo = accessory.getService(Service.Thermostat);

    accessory.context.active = status.group_has_sensor && status.group_control_type;
    thermo.setCharacteristic(Characteristic.TargetHeatingCoolingState, accessory.context.active * 3);

    const ac = Object.entries(this.units)[0][1];
    accessory.context.currentHeatingCoolingState = accessory.context.active * ac.getService(Service.Thermostat).getCharacteristic(Characteristic.CurrentHeatingCoolingState).value;
    thermo.setCharacteristic(Characteristic.CurrentHeatingCoolingState, accessory.context.currentHeatingCoolingState);

    accessory.context.currentTemperature = status.group_temp;
    thermo.setCharacteristic(Characteristic.CurrentTemperature, accessory.context.currentTemperature);

    accessory.context.targetTemperature = status.group_target;
    thermo.setCharacteristic(Characteristic.TargetTemperature, accessory.context.targetTemperature);

    // save history as Eve Room
    //accessory.historyService.addEntry({
    //	time: new Date().getTime() / 1000,
    //	temp: accessory.context.currentTemperature
    //});

    accessory.updateReachability(true);
    this.log.debug('Finished updating accessory [' + accessory.displayName + ']');
  }


  /* ----------------------------------------------------------------------------------------------------- */

  /* AC accessory function */

  acSetTargetHeatingCoolingState(val, cb) {
    if (this.context.targetHeatingCoolingState !== val) {
      this.context.targetHeatingCoolingState = val;
      if (this.context.currentHeatingCoolingState != val) {
        this.airtouch.acSetCurrentHeatingCoolingState(this.context.serial, val);
      }
    }
    cb();
  }

  acSetTargetTemperature(val, cb) {
    if (this.context.targetTemperature != val) {
      this.context.targetTemperature = val;
      this.airtouch.acSetTargetTemperature(this.context.serial, val);
    }
    cb();
  }

  acSetRotationSpeed(val, cb) {
    if (this.context.rotationSpeed != val) {
      this.context.rotationSpeed = val;
      // convert homebridge fan rotation % into AC fan speed string (e.g. 99% => High) using the config array
      const fan_speed = this.context.fan_speeds[val / this.context.rotation_step];
      // convert AC fan speed string in AC fan speed number (e.g. High => 4) and update AC
      this.airtouch.acSetFanSpeed(this.context.serial, MAGIC.AC_FAN_SPEEDS[fan_speed]);
    }
    cb();
  }

  /* /AC accessory functions */

  /* Zone accessory functions */

  zoneSetActive(val, cb) {
    if (this.context.active != val) {
      this.context.active = val;
      this.airtouch.zoneSetActive(this.context.serial, val);
    }
    cb();
  }

  zoneSetDamperPosition(val, cb) {
    // set damper position only when percentage control type is selected
    if (this.context.controlType == MAGIC.GROUP_CONTROL_TYPES.DAMPER - 2 && this.context.damperPosition != val) {
      this.context.damperPositon = val;
      this.airtouch.zoneSetDamperPosition(this.context.serial, val);
    } else if (this.context.damperPosition != val) {
      // reset the GUI to the old damper position when temperature control type is selected
      this.getService(Service.Window).setCharacteristic(Characteristic.CurrentPosition, this.context.damperPosition);
      this.getService(Service.Window).setCharacteristic(Characteristic.TargetPosition, this.context.damperPosition);
    }
    cb();
  }

  /* /Zone accessory functions */

  /* Thermo accessory functions */

  thermoSetActive(val, cb) { // 0 = OFF, 3 = AUTO (ON)
    // sets control type
    if (this.context.active != (val % 2)) {
      this.context.active = (val % 2);
      this.airtouch.zoneSetControlType(this.context.serial, (val % 2)); // 0 = DAMPER (OFF), 1 = TEMPERATURE (ON)
    }
    cb();
  }

  thermoSetTargetTemperature(val, cb) {
    // sets zone target temperature
    if (this.context.active && this.context.targetTemperature != val) {
      this.context.targetTemperature = val;
      this.airtouch.zoneSetTargetTemperature(this.context.serial, val);
    }
    cb();
  }

  /* /Thermo accessory functions */
}


